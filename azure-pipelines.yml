trigger:
  branches:
    include:
      - main
      - development
  paths:
    exclude:
      - README.md
      - docs/*

pool:
  vmImage: 'ubuntu-latest'

variables:
  isMain: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  isDev: $[eq(variables['Build.SourceBranch'], 'refs/heads/development')]
  # ğŸ”§ CHANGEZ CES VALEURS SELON VOTRE CONFIGURATION
  dockerRegistryServiceConnection: 'votre-nom-service-connection'  # Remplacez par le nom rÃ©el
  imageRepository: 'system-transport'
  containerRegistry: 'votre-registry.azurecr.io'  # Remplacez par votre ACR
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  azureSubscription: 'votre-azure-subscription'  # Remplacez par votre subscription

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildAndTest
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Install Node.js'

    - script: |
        echo "ğŸ“ Documentation: Setting up Node.js environment"
        echo Node.js and npm versions:
        node -v
        npm -v
        
        echo Installing pnpm...
        npm install -g pnpm
        pnpm --version
      displayName: 'Install pnpm'

    - script: |
        echo "ğŸ“ Documentation: Installing project dependencies"
        echo Cleaning existing directories...
        rm -rf node_modules
        rm -rf .next
        
        echo Installing dependencies with pnpm...
        pnpm install --prefer-frozen-lockfile
        
        echo Checking installation...
        ls -la node_modules
      displayName: 'Install Dependencies'
      
    - script: |
        echo "ğŸ“ Documentation: Running ESLint for code quality"
        echo Running linting with ESLint...
        pnpm lint
      displayName: 'Run ESLint'
      continueOnError: false

    - script: |
        echo "ğŸ“ Documentation: Running Jest unit tests"
        echo Running tests with Jest...
        pnpm test:ci
      displayName: 'Run Jest Tests'
      continueOnError: false
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/junit.xml'
        mergeTestResults: true
        testRunTitle: 'Unit Tests'
      displayName: 'Publish Test Results'
      condition: succeededOrFailed()

    - script: |
        echo "ğŸ“ Documentation: Building Next.js application"
        echo Building application...
        pnpm build
      displayName: 'Build Application'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '.next'
        ArtifactName: 'next-build'
        publishLocation: 'Container'
      displayName: 'Publish Next.js Build'

- stage: Docker
  displayName: 'Docker Build and Push'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DockerBuildPush
    displayName: 'Build and Push Docker Image'
    steps:
    - checkout: self
      
    # ğŸ”§ TÃ¢che Docker corrigÃ©e avec gestion d'erreur
    - task: Docker@2
      displayName: 'Build Docker image'
      inputs:
        command: build
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest
      # ğŸ”§ Ajout de conditions pour debug
      continueOnError: false
      
    - task: Docker@2
      displayName: 'Push Docker image'
      inputs:
        command: push
        repository: $(imageRepository)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest
      continueOnError: false
          
    - script: |
        echo "ğŸ“ Documentation: Docker image built and pushed to registry"
        echo "Image: $(containerRegistry)/$(imageRepository):$(tag)"
        echo "Image: $(containerRegistry)/$(imageRepository):latest"
      displayName: 'Log Docker Image Details'

- stage: Deploy
  displayName: 'Continuous Deployment'
  dependsOn: Docker
  condition: and(succeeded(), eq(variables.isMain, true))
  jobs:
  - job: DeployToAzure
    displayName: 'Deploy to Azure Web App'
    steps:
    - checkout: self
    
    - task: AzureWebApp@1
      displayName: 'Deploy to Azure Web App'
      inputs:
        azureSubscription: $(azureSubscription)
        appType: 'webAppContainer'
        appName: 'system-transport-app'  # ğŸ”§ Remplacez par le nom rÃ©el de votre Web App
        deployToSlotOrASE: true
        resourceGroupName: 'system-transport-rg'  # ğŸ”§ Remplacez par votre Resource Group
        slotName: 'production'
        containers: '$(containerRegistry)/$(imageRepository):$(tag)'
        
    - script: |
        echo "ğŸ“ Documentation: Application deployed to Azure Web App"
        echo "App URL: https://system-transport-app.azurewebsites.net"
      displayName: 'Log Deployment Details'

# ğŸ”§ Ajout d'un stage de validation pour vÃ©rifier les service connections
- stage: Validation
  displayName: 'Validate Configuration'
  dependsOn: []
  condition: always()
  jobs:
  - job: ValidateConfig
    displayName: 'Validate Service Connections'
    steps:
    - script: |
        echo "ğŸ” Validation des configurations:"
        echo "Service Connection: $(dockerRegistryServiceConnection)"
        echo "Container Registry: $(containerRegistry)"
        echo "Azure Subscription: $(azureSubscription)"
        echo "Image Repository: $(imageRepository)"
        echo ""
        echo "âš ï¸ VÃ©rifiez que ces valeurs correspondent Ã  votre configuration Azure!"
      displayName: 'Display Configuration'
      
- stage: Monitoring
  displayName: 'Monitoring and Logging'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: SetupMonitoring
    displayName: 'Setup Monitoring'
    steps:
    - script: |
        echo "ğŸ“ Documentation: Setting up monitoring and logging"
        echo "Setting up monitoring placeholder (to be replaced with Prometheus)"
        echo "Creating monitoring configuration..."
        mkdir -p $(Build.ArtifactStagingDirectory)/monitoring
        
        echo "# Prometheus Configuration Placeholder" > $(Build.ArtifactStagingDirectory)/monitoring/prometheus.yml
        echo "scrape_configs:" >> $(Build.ArtifactStagingDirectory)/monitoring/prometheus.yml
        echo "  - job_name: 'system-transport'" >> $(Build.ArtifactStagingDirectory)/monitoring/prometheus.yml
        echo "    static_configs:" >> $(Build.ArtifactStagingDirectory)/monitoring/prometheus.yml
        echo "      - targets: ['system-transport-app:3000']" >> $(Build.ArtifactStagingDirectory)/monitoring/prometheus.yml
        
        echo "# Logging Configuration Placeholder" > $(Build.ArtifactStagingDirectory)/monitoring/logging.yml
        echo "Application deployed and ready for monitoring setup"
      displayName: 'Configure Monitoring'
      
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/monitoring'
        ArtifactName: 'monitoring-config'
        publishLocation: 'Container'
      displayName: 'Publish Monitoring Configuration'

- stage: Documentation
  displayName: 'Pipeline Documentation'
  dependsOn: []
  condition: succeeded()
  jobs:
  - job: GenerateDocumentation
    displayName: 'Generate Pipeline Documentation'
    steps:
    - script: |
        echo "ğŸ“š System Transport CI/CD Pipeline Documentation"
        echo "================================================"
        echo ""
        echo "This pipeline performs the following steps:"
        echo "1. ğŸ” Validation: VÃ©rification des configurations"
        echo "2. ğŸ” Linting: ESLint is used to ensure code quality"
        echo "3. ğŸ§ª Testing: Jest unit tests are executed"
        echo "4. ğŸ—ï¸ Building: Next.js application is built"
        echo "5. ğŸ³ Docker: Application is containerized and image pushed to registry"
        echo "6. ğŸš€ Deployment: Continuous deployment to Azure Web App"
        echo "7. ğŸ“Š Monitoring: Placeholder for Prometheus monitoring setup"
        echo ""
        echo "Pipeline last updated: $(date)"
      displayName: 'Generate Documentation'